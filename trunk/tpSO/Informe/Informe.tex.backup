\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{verbatim}
% \usepackage{lstlisting}
\usepackage{subfig}
\usepackage{float}
 \usepackage[spanish]{babel}   %ver bien como es
\usepackage[utf8]{inputenc}


\begin{document}
\tableofcontents
\newpage
\begin{center}
\section*{Aclaraciones Generales}
\addcontentsline{toc}{section}{Aclaraciones Generales}
\end{center}

\section*{Comandos B\'asicos de Unix}
\addcontentsline{toc}{section}{Comandos b\'asicos de Unix}

A continuaci\'on se presentan los comandos b\'asicos utilizados y las explicaciones correspondientes:
\begin{itemize}
\item pwd: El comando pwd es una abreviatura de Print Working Directory. Como su nombre lo indica, su funci\'on es imprimir por pantalla el directorio actual.

Si se ejecuta el comando cd /usr/bin y luego se utiliza el comando pwd, justamente se imprime por pantalla /usr/bin ya que la funci\'on que realiza el comando cd es cambiar el directorio posicionandonos sobre el especificado, en este caso /usr/bin. Luego, el comando pwd nos indica la realizaci\'on de este cambio de directorio.

Si ejecuta el comando cd sin especificar directorio al cual se desea cambiar y luego se ejecuta el comando pwd, entonces el mismo imprime por pantalla /home/grupo5. Esto sucede de esta manera, ya que si al comando cd no se le pasan par\'ametros, el mismo cambia el directorio al home. En nuestro caso, /home/grupo5. En la figura 1, se puede ver como funciona el comando.

\item cat: El comando cat se utiliza, en este caso, para imprimir por pantalla el contenido del archivo especificado. De este manera, se puede ver el contenido del archivo .profile. Cabe destacar que el comando cat no solo se utiliza para este fin, el mismo tambi\'en tiene otros usos como concatenar archivos en un archivo nuevo. Ademas, existen varios flags para modificar el comportamiento del comando, tal como ademas de imprimir el archivo, imprimir el n\'umero de linea. En la figura 2, se puede ver como se muestra el archivo .profile al utilizar el comando cat.

\item find:

\item mkdir: El comando mkdir es una abreviatura de Make Directory, el mismo sirve justamente para crear directorios especificando el nombre del directorio a crear. Este comando se puede utilizar para crear varios directorios a la vez, y tambi\'en se puede hacer uso de distintos flags por ejemplo para crear directorios de solo lectura. Al utilizar el comando mkdir tp estando en /home/grupo5, se crea un directorio llamado tp dentro de donde se esta posicionado. En la figura 3, se puede ver como el comando creo el directorio y luego se lo accede.

\item cp: El comando cp proviene de la palabra copy, justamente la utilidad del mismo es poder copiar archivos. En el caso de ejecutar cp /etc/passwd /home/grupo5/tp lo que se esta haciendo es copiar el archivo fuente (/etc/passwd) al directorio destino, que en este caso es el directorio tp creado recientemente. En la figura 4 se puede ver como al utilizar el comando cp, encontramos el archivo passwd dentro del directorio tp.

\item chgrp, chown y chmod: Los comandos chgrp, chown y chmod provienen de Change Group, Change Owner y Change Mode respectivamente. Los mismos se utilizan justamente para cambiar el grupo de un archivo, el owner y los permisos de accesos del mismo. 

Para utilizar los dos primeros comandos se debe especificar el nombre del grupo u owner nuevo y el archivo que se quiere modificar. En los casos pedidos la sintaxis ser\'ia, chgrp grupo5 /home/grupo5/tp/passwd y chown grupo5 /home/grupo5/tp/passwd. Luego de ejecutar estos dos comandos, el grupo y el owner de passwd pasan a ser grupo5. Esto se puede ver utilizando el comando ls -l.

Luego, para utilizar el comando chmod, se debe especificar cuales son los permisos a cambiar y a quien se quiere asignar o desasignar estos permisos. Para lograr lo pedido en este trabajo pr\'actico las sentencias a utilizar ser\'ian: chmod u+rwx passwd, chmod g+rx passwd, chmod o+x passwd. El primer comando es para cambiar el user, y le asigna(+) Read, Write y eXecute. El segundo comando le asigna Read y eXecute al Grupo. Por \'ultimo, el tercer comando asigna eXecute a los demas (Others). Cabe destacar que como el archivo ya traia permisos de Read para los Others, se quitaron los mismos utilizando chmod o-r passwd.

En la figura 5 se puede ver la utilizaci\'on de todos estos comandos y se miran los atributos del archivo mediante el comando ls -l, para ver como van cambiando el grupo, el owner y los permisos a medida que se van utilizando los comandos explicados.

Cabe destacar que el comando chmod se utiliz\'o varias veces para ir cambiando de a poco los permisos seg\'un sean para el usuario, para el grupo o para los otros. Sin embargo, esto se puede realizar utilizando una sola vez el comando chmod. La sintaxis para el mismo ser\'ia chmod 751 passwd. El numero 751 esta es una manera de codificar los permisos, el 7(111) corresponde al user y esta poniendo en 1 los 3 permisos; el 5(101) es para el grupo, dado un orden predispuesto, lo que hace esto es setear en 1 los permisos de Read y eXecute, que son el primero y el tercero respectivamente, y setea en 0 el segundo permiso(Write). Por \'ultimo, el 1(001) corresponde a setear el permiso de eXecute para los Others.

\item grep: El comando grep es para buscar expresiones regulares dentro de un archivo. En el caso pedido lo que se quiere es buscar la expresion localhost dentro del archivo /etc/hosts. Para esto se utiliza el comando de la siguiente manera: grep localhosts /etc/hosts. De esta manera, se visualiza(figura 6) como el comando grep imprime las lineas del archivo hosts en donde aparece la expresi\'on localhosts.

Luego, se pide realizar la misma acci\'on pero sobre todos los archivos del directorio /etc.
falta ver como evitar los binarios y los que no se tiene permiso.

\item passwd: El comando passwd se utiliza para manejar contrase\~{n}as. El mismo posee varias flags para distintas opciones. Sin embargo, si se utiliza sin ninguna opci\'on, su funci\'on por default es cambiar el password del user. Primero pide escribir el viejo password (mesaverde) y luego pide asginar un nuevo password y confirmarlo (mesaverde2).

\item rm: El comando rm provine de la palabra remove. El mismo se puede utilizar con diferentes opciones si se quieren eliminar directorios recursivamente por ejemplo. En el caso pedido, solo hay que eleminar el archivo passwd, por lo que la sintaxis es rm passwd. En la figura 8 se puede ver el cambio de password y la eliminacion del archivo conjuntamente.

\item ln: El comando ln se utiliza para crear links entre archivos. Para utilizar el comando ln se debe especificar el archivo fuente y el archivo destino. Cabe destacar que el uso de este comando sin ning\'un flag creara un hard link. Para realizar lo pedido en el trabajo pr\'actico la sintaxis utilizada fue la siguiente: ln /etc/passwd /tmp/contra1 y ln /etc/passwd /tmp/contra2. En la figura 9 se puede ver como se utilizan estos dos comandos y luego, realizando ls -l, se puede ver que ahora hay 3 links al archivo /etc/passwd.

Para realizar un soft link o link simbolico se debe agregar la opci\'on -s al utilizar el comando. En la figura 9 se puede ver la utilizaci\'on del comando ln -s /etc/passwd /tmp/contra3 y luego se puede ver como no cambia la cantidad de hard links usando el comando ls -l.

\item mount: Para realizar lo pedido, debemos utilizar el comando mount de la siguiente manera: mount /dev/cdrom de esta manera, estamos montando el cdrom. Luego para poder ver los filesystems que estan montados debemos ver el archivo /etc/mtab. En la figura 10, se puede ver como se monta la unidad de cd y luego haciendo cat /etc/mtab se muestran los filesystems montados.

\item df y ps: Los comandos df y ps sirven para mostrar el espacio libre de los filesystems y los procesos que se tienen ejecutando. En la figura 11, se puede ver la utilizaci\'on de los mismos.

\item umount: El comando umount sirve para desmontar el disposito de cdrom utilizando la sintaxis umount /dev/cdrom. En la figura 12 se puede ver como se utiliza este comando y como luego al utilizar el comando df, se ve como el filesystem del cd ya no se muestra.

\item uptime y uname: Estos comandos se utilizan para saber cuanto tiempo lleva el sistema corriendo y para saber que version del kernel. En la figura 13 se puede ver la utilizaci\'on del comando uptime y luego el comando uname -a para ver toda la informaci\'on, incluyendo la informaci\'on sobre el sistema operativo.

\end{itemize}

\section*{Comandos Extendidos de Unix}
\addcontentsline{toc}{section}{Comandos Extendidos de Unix}

\subsection*{Ejecuci\'on autom\'atica}
\addcontentsline{toc}{subsection}{Ejecuci\'on autom\'atica}

\begin{itemize}
\item Para poder imprimir un hola por pantalla cada vez que un usuario se loguea, se debe modificar el archivo pertinente. En este caso, para que el hola aparezca cuando se loguea cualquier usuario se debe modificar el archivo /etc/.profile. En dicho archivo, se debe agregar una linea que especifique la acci\'on requerida, la sintaxis es simplemente echo Hola. Luego, cada vez que un usuario se loguee, el archivo .profile se correra y el mismo indicar\'a que se imprima Hola por pantalla.

\item Buenos Dias: explicar del script en init.d y del update-rc


\item Para poder imprimir un Adios por pantalla cada vez que un usuario se desloguea el proceso es diferente al realizado en el primer item de este punto. La manera debe ser diferente debido a que, a diferencia del fichero profile, no hay un fichero que se corra automaticamente al hacer logout, a menos que se as\'i se lo indique. 

Para poder indicarle al sistema que se quiere correr un archivo al hacer logout lo que se realiz\'o fue modificar nuevamente el fichero /etc/profile con la siguiente linea de comando: trap '. /etc/.logout;exit' 0. Lo que hace el comando trap es darle una directiva al sistema operativo, en este caso lo que hace es darle la directiva de que cuando se reciba una se\~{n}al de exit(logout) se corra el fichero .logout.

Luego, se creo un archivo .logout con los scripts que se quisiesen correr a la hora del logout, en nuestro caso el archivo consta solamente de una linea que indica la impresion de una linea de Adios. La sintaxis dentro del archivo es simplemente echo Adios.

Por \'ultimo lo que se realiz\'o fue hacer chmod 755 .logut, esto se hizo para que el archivo tuviese permisos de ejecuci\'on.

\item Hasta la vista baby ver bien como hacerlo


\end{itemize}

\subsection*{Dispositivos Especiales}
\addcontentsline{toc}{subsection}{Dispositivos especiales}

\subsection*{Cambio de Hora}
\addcontentsline{toc}{subsection}{Cambio de hora}

\subsection*{Lapsos y Tiempos}
\addcontentsline{toc}{subsection}{Lapsos y tiempos}

\subsection*{Salida Est\'andar y Pipes}
\addcontentsline{toc}{subsection}{Salida est\'andar y pipes}

STDOUT:

En primer lugar se utiliz\'o el siguiente comando para volcar la informaci\'on pedida: ls -R $>>$ /home/grupo5/tp/config. El mismo se utiliz\'o estando en el directorio /etc, de esta manera el comando ls -R lo que hizo fue lista recusirvamente todos el contenido del directorio y su subdirectorios. Mientras que $>>$ lo que hizo fue volcar esta informaci\'on al archivo especificado.

Para obtener la informaci\'on sobre la cantidad de lineas, palabras y caracteres se utiliz\'o el comando wc con las opciones necesarios en cada caso (-l, -w, -m). El resultado fue: 665 lineas, 593 palabras y 7305 caracteres.

En tercer lugar, se buscar ordenar el contenido de /etc/passwd y ponerlo al final del archivo config anteriormente nombrado. Para ordenar se utiliz\'o el comando sort, mientras que para volcar en el archivo nuevamente se utilizo $>>$. De esta manera la sintaxis utilizada fue: sort /etc/passwd $>>$ /home/grupo5/tp/config

Por \'ultimo se procedi\'o a contar las lineas, palabras y caracteres del archivo de la misma forma que se habia realizado anteriormete, el resultado fue: 688 lineas, 621 palabras y 8238 caracteres.


Pipes: Para realizar lo pedido, sin utilizar archivos temporales, se ejecut\'o la siguiente linea de comando que hace lo que el ejercicio pide, en el orden requerido. La sintaxis es: ls -al /usr/bin/a* | grep apt | wc. La misma es una combinaci\'on de los comandos utilizados en puntos anteriores, para lograr todos los efectos requeridos.



\section*{Scripting}
\addcontentsline{toc}{section}{Scripting}

3.3.1: En este punto se debe hacer un script que cada 5 minutos diga HOLA por pantalla. Para esto, se utilizaron dos resoluciones diferentes, una que es totalmente autom\'atica y la otra semiautom\'atica. 

Por un lado, se realizo un script de shell que, una vez ejecutado, corriese un ciclo infinito; dentro de este ciclo, el script espera 300 segundos mediante el comando sleep 300 y luego hace un echo HOLA para imprimir por pantalla la palabra requerida. Esta soluci\'on requiere que el usuario ejecute el script. Dicho script se encuentra en la carpeta /home/grupo5/tp.

Por otro lado, se encuentra otra soluci\'on totalmente autom\'atica, es decir que no requiere que el usuario ejecute el script. La misma consiste en agregar una entrada a la crontable que indique que se debe imprimir HOLA cada 5 minutos. Cabe destacar que la distribuci\'on de ubuntu utilizada para este trabajo, no cuenta con el cron por lo que fue necesario instalarlo. Una vez instalado, se agrega en la tabla la entrada correspondiente. Dicha entrada tiene la siguiente sintaxis: */5  * * * * root echo HOLA $>>$ /dev/console. Esta sintaxis dice que, cada 5 minutos, a cualquier hora, en cualquier dia, en cualquier mes y en cualquier dia de la semana; el usuario root corra el comando echo HOLA y lo imprima en la consola.

Para hacer lo mismo pero a una hora determinada, se debe explicitar la hora requerida en la entrada de la crontable. Por ejemplo, en la imagen se encuentra la entrada 25 7 * * * root echo HOLA $>>$ /dev/console. Esta entrada tiene la misma acci\'on que la anterior, pero se ejecuta todos los d\'ias a las 7 y 25. 

\bigskip


3.3.2

Hay que robarse este script!!!

\section*{Ejecuci\'on de Procesos en Background}
\addcontentsline{toc}{section}{Ejecuci\'on de procesos en background}

En primer lugar, se procedi\'o a transcribir el programa loop, se guardo el mismo en el directorio /home/grupo5/tp. Una vez transcripto, se procedio a compilar el mismo utilizando el gcc. 

\bigskip

En primer lugar el proceso se corri\'o en foreground. Esto quiere decir que el proceso toma el control de la terminal que se esta utilizando, es decir que se corre en un primer plano. El problema con este proceso es que el mismo contiene un ciclo infinito que escribe en la pantalla. Como el proceso esta corriendo en foreground, y el ciclo es infinito, el mismo nunca devuelve el control de la terminal y sigue ensuciando la consola sin poder realizar otra acci\'on. Luego, se mat\'o el proceso mediante Ctrl+C para poder interrumpirlo y as\'i volver a tomar el control de la terminal.

\section*{IPC y Sincronizaci\'on}
\addcontentsline{toc}{section}{IPC y Sincronizaci\'on}

\section*{El Kernel Linux}
\addcontentsline{toc}{section}{El Kernel Linux}

\section*{Temas del Sistema Operativo}
\addcontentsline{toc}{section}{Temas del Sistema Operativo}





\end{document}


bibliografia:

http://www.linux-es.org/node/127 pagina para explicacion de chgrp, chown y chmod
http://www.oreillynet.com/linux/cmd pagina de comandos de linux
http://www.computerhope.com/unix pagina de comandos de linux
http://linuxcommand.gds.tuwien.ac.at paginas para hacer scripts
http://www.bulma.net/body.phtml?nIdNoticia=50 Habla sobre .profile y .bashrc
http://bloggerdigest.blogspot.com/2006/10/enable-linux-login-logout-scripts.html explicar como hacer el script para el logout.
http://www.linuxforums.org/forum/linux-programming-scripting/12551-simple-shutdown-script.html Script para apagar automaticamente

http://www.debian-administration.org/article/Making_scripts_run_at_boot_time_with_Debian Script para poner Buenos Dias cuando se prende

http://www.laps3.com/foro/19_guias_tutoriales/23114-manual_de_shell_linux_comandos_basicos_utilizaion_ejemplos.html Pagina que ensena a contar palabras, lineas y caracteres.

http://www.unix.com/es/shell-programming-scripting/111483-script-run-every-5-minutes.html

http://www.hedeshian.com/node/12 Pagina que explicar que el ubuntu jeos no viene con crontab

http://www.linuxtotal.com.mx/index.php?cont=info_admon_006 manual de cron

http://www.ace.ual.es/~vruiz/docencia/cursos/linux/html/node48.html pagina que explicar que significa correr en background y foreground

