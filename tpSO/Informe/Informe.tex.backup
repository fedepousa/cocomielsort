\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{verbatim}
% \usepackage{lstlisting}
\usepackage{subfig}
\usepackage{float}
 \usepackage[spanish]{babel}   %ver bien como es
\usepackage[utf8]{inputenc}


\begin{document}
\tableofcontents
\newpage
\begin{center}
\section*{Aclaraciones Generales}
\addcontentsline{toc}{section}{Aclaraciones Generales}
\end{center}

\section*{Comandos B\'asicos de Unix}
\addcontentsline{toc}{section}{Comandos b\'asicos de Unix}

A continuaci\'on se presentan los comandos b\'asicos utilizados y las explicaciones correspondientes:
\begin{itemize}
\item pwd: El comando pwd es una abreviatura de Print Working Directory. Como su nombre lo indica, su funci\'on es imprimir por pantalla el directorio actual.

Si se ejecuta el comando cd /usr/bin y luego se utiliza el comando pwd, justamente se imprime por pantalla /usr/bin ya que la funci\'on que realiza el comando cd es cambiar el directorio posicionandonos sobre el especificado, en este caso /usr/bin. Luego, el comando pwd nos indica la realizaci\'on de este cambio de directorio.

Si ejecuta el comando cd sin especificar directorio al cual se desea cambiar y luego se ejecuta el comando pwd, entonces el mismo imprime por pantalla /home/grupo5. Esto sucede de esta manera, ya que si al comando cd no se le pasan par\'ametros, el mismo cambia el directorio al home. En nuestro caso, /home/grupo5. En la figura 1, se puede ver como funciona el comando.

\item cat: El comando cat se utiliza, en este caso, para imprimir por pantalla el contenido del archivo especificado. De este manera, se puede ver el contenido del archivo .profile. Cabe destacar que el comando cat no solo se utiliza para este fin, el mismo tambi\'en tiene otros usos como concatenar archivos en un archivo nuevo. Ademas, existen varios flags para modificar el comportamiento del comando, tal como ademas de imprimir el archivo, imprimir el n\'umero de linea. En la figura 2, se puede ver como se muestra el archivo .profile al utilizar el comando cat.

\item find: Este comando se utiliza para buscar archivos dentro de directorios. Para ejecutar lo pedido se utilizo la sintaxis: sudo find -name vmlinuz*. El mismo indica que se deben buscar los archivos que coincidan en nombre con vmlinuz y luego el asterisco indica que puede seguir de diferentes maneras. Cabe destacar que se necesita permisos de superusuario para poder explorar ciertas carpetas que tiene restricci\'o.

\item mkdir: El comando mkdir es una abreviatura de Make Directory, el mismo sirve justamente para crear directorios especificando el nombre del directorio a crear. Este comando se puede utilizar para crear varios directorios a la vez, y tambi\'en se puede hacer uso de distintos flags por ejemplo para crear directorios de solo lectura. Al utilizar el comando mkdir tp estando en /home/grupo5, se crea un directorio llamado tp dentro de donde se esta posicionado. En la figura 3, se puede ver como el comando creo el directorio y luego se lo accede.

\item cp: El comando cp proviene de la palabra copy, justamente la utilidad del mismo es poder copiar archivos. En el caso de ejecutar cp /etc/passwd /home/grupo5/tp lo que se esta haciendo es copiar el archivo fuente (/etc/passwd) al directorio destino, que en este caso es el directorio tp creado recientemente. En la figura 4 se puede ver como al utilizar el comando cp, encontramos el archivo passwd dentro del directorio tp.

\item chgrp, chown y chmod: Los comandos chgrp, chown y chmod provienen de Change Group, Change Owner y Change Mode respectivamente. Los mismos se utilizan justamente para cambiar el grupo de un archivo, el owner y los permisos de accesos del mismo. 

Para utilizar los dos primeros comandos se debe especificar el nombre del grupo u owner nuevo y el archivo que se quiere modificar. En los casos pedidos la sintaxis ser\'ia, chgrp grupo5 /home/grupo5/tp/passwd y chown grupo5 /home/grupo5/tp/passwd. Luego de ejecutar estos dos comandos, el grupo y el owner de passwd pasan a ser grupo5. Esto se puede ver utilizando el comando ls -l.

Luego, para utilizar el comando chmod, se debe especificar cuales son los permisos a cambiar y a quien se quiere asignar o desasignar estos permisos. Para lograr lo pedido en este trabajo pr\'actico las sentencias a utilizar ser\'ian: chmod u+rwx passwd, chmod g+rx passwd, chmod o+x passwd. El primer comando es para cambiar el user, y le asigna(+) Read, Write y eXecute. El segundo comando le asigna Read y eXecute al Grupo. Por \'ultimo, el tercer comando asigna eXecute a los demas (Others). Cabe destacar que como el archivo ya traia permisos de Read para los Others, se quitaron los mismos utilizando chmod o-r passwd.

En la figura 5 se puede ver la utilizaci\'on de todos estos comandos y se miran los atributos del archivo mediante el comando ls -l, para ver como van cambiando el grupo, el owner y los permisos a medida que se van utilizando los comandos explicados.

Cabe destacar que el comando chmod se utiliz\'o varias veces para ir cambiando de a poco los permisos seg\'un sean para el usuario, para el grupo o para los otros. Sin embargo, esto se puede realizar utilizando una sola vez el comando chmod. La sintaxis para el mismo ser\'ia chmod 751 passwd. El numero 751 esta es una manera de codificar los permisos, el 7(111) corresponde al user y esta poniendo en 1 los 3 permisos; el 5(101) es para el grupo, dado un orden predispuesto, lo que hace esto es setear en 1 los permisos de Read y eXecute, que son el primero y el tercero respectivamente, y setea en 0 el segundo permiso(Write). Por \'ultimo, el 1(001) corresponde a setear el permiso de eXecute para los Others.

\item grep: El comando grep es para buscar expresiones regulares dentro de un archivo. En el caso pedido lo que se quiere es buscar la expresion localhost dentro del archivo /etc/hosts. Para esto se utiliza el comando de la siguiente manera: grep localhosts /etc/hosts. De esta manera, se visualiza(figura 6) como el comando grep imprime las lineas del archivo hosts en donde aparece la expresi\'on localhosts.

Luego, se pide realizar la misma acci\'on pero sobre todos los archivos del directorio /etc.
Para esto se utiliza la siguiente sintaxis: grep -r POSIX | grep -v Binary. Lo que hace este comando es primero buscar recursivamente (-r) los archivos que concuerden, luego con estos archivos encontrados se hace otra busqueda con -v que indica que hay que evitar los que coincidan con Binary.

\item passwd: El comando passwd se utiliza para manejar contrase\~{n}as. El mismo posee varias flags para distintas opciones. Sin embargo, si se utiliza sin ninguna opci\'on, su funci\'on por default es cambiar el password del user. Primero pide escribir el viejo password (mesaverde) y luego pide asginar un nuevo password y confirmarlo (mesaverde2).

\item rm: El comando rm proviene de la palabra remove. El mismo se puede utilizar con diferentes opciones si se quieren eliminar directorios recursivamente por ejemplo. En el caso pedido, solo hay que eleminar el archivo passwd, por lo que la sintaxis es rm passwd. En la figura 8 se puede ver el cambio de password y la eliminacion del archivo conjuntamente.

\item ln: El comando ln se utiliza para crear links entre archivos. Para utilizar el comando ln se debe especificar el archivo fuente y el archivo destino. Cabe destacar que el uso de este comando sin ning\'un flag creara un hard link. Para realizar lo pedido en el trabajo pr\'actico la sintaxis utilizada fue la siguiente: ln /etc/passwd /tmp/contra1 y ln /etc/passwd /tmp/contra2. En la figura 9 se puede ver como se utilizan estos dos comandos y luego, realizando ls -l, se puede ver que ahora hay 3 links al archivo /etc/passwd.

Para realizar un soft link o link simbolico se debe agregar la opci\'on -s al utilizar el comando. En la figura 9 se puede ver la utilizaci\'on del comando ln -s /etc/passwd /tmp/contra3 y luego se puede ver como no cambia la cantidad de hard links usando el comando ls -l.

\item mount: Para realizar lo pedido, debemos utilizar el comando mount de la siguiente manera: mount /dev/cdrom de esta manera, estamos montando el cdrom. Luego para poder ver los filesystems que estan montados debemos ver el archivo /etc/mtab. En la figura 10, se puede ver como se monta la unidad de cd y luego haciendo cat /etc/mtab se muestran los filesystems montados.

\item df y ps: Los comandos df y ps sirven para mostrar el espacio libre de los filesystems y los procesos que se tienen ejecutando. El comando ps, se utiliza con la opcion -A para listar todos los procesos y ahi se pueden notar cuales son del sistema y cuales son de los usuarios. En la figura 11, se puede ver la utilizaci\'on de los mismos.

\item umount: El comando umount sirve para desmontar el disposito de cdrom utilizando la sintaxis umount /dev/cdrom. En la figura 12 se puede ver como se utiliza este comando y como luego al utilizar el comando df, se ve como el filesystem del cd ya no se muestra.

\item uptime y uname: Estos comandos se utilizan para saber cuanto tiempo lleva el sistema corriendo y para saber que version del kernel. En la figura 13 se puede ver la utilizaci\'on del comando uptime y luego el comando uname -a para ver toda la informaci\'on, incluyendo la informaci\'on sobre el sistema operativo.

\end{itemize}

\section*{Comandos Extendidos de Unix}
\addcontentsline{toc}{section}{Comandos Extendidos de Unix}

\subsection*{Ejecuci\'on autom\'atica}
\addcontentsline{toc}{subsection}{Ejecuci\'on autom\'atica}

\begin{itemize}
\item Para poder imprimir un hola por pantalla cada vez que un usuario se loguea, se debe modificar el archivo pertinente. En este caso, para que el hola aparezca cuando se loguea cualquier usuario se debe modificar el archivo /etc/.profile. En dicho archivo, se debe agregar una linea que especifique la acci\'on requerida, la sintaxis es simplemente echo Hola. Luego, cada vez que un usuario se loguee, el archivo .profile se correra y el mismo indicar\'a que se imprima Hola por pantalla.

\item Buenos Dias: explicar del script en init.d y del update-rc


\item Para poder imprimir un Adios por pantalla cada vez que un usuario se desloguea el proceso es diferente al realizado en el primer item de este punto. La manera debe ser diferente debido a que, a diferencia del fichero profile, no se encontro un fichero que se corra automaticamente al hacer logout. 

Para poder indicarle al sistema que se quiere correr un archivo al hacer logout lo que se realiz\'o fue modificar nuevamente el fichero /etc/profile con la siguiente linea de comando: trap '. /etc/.logout;exit' 0. Lo que hace el comando trap es darle una directiva al sistema operativo, en este caso lo que hace es darle la directiva de que cuando se reciba una se\~{n}al de exit(logout) se corra el fichero .logout.

Luego, se creo un archivo .logout con los scripts que se quisiesen correr a la hora del logout, en nuestro caso el archivo consta solamente de una linea que indica la impresion de una linea de Adios. La sintaxis dentro del archivo es simplemente echo Adios.

Por \'ultimo lo que se realiz\'o fue hacer chmod 755 .logut, esto se hizo para que el archivo tuviese permisos de ejecuci\'on.

\item Hasta la vista baby ver bien como hacerlo


\end{itemize}

\subsection*{Dispositivos Especiales}
\addcontentsline{toc}{subsection}{Dispositivos especiales}

\subsection*{Cambio de Hora}
\addcontentsline{toc}{subsection}{Cambio de hora}

Para esta secci\'on lo primero que hay que hacer es crear un alias en el fichero deseado. Para eso se debe editar este archivo y poner algun alias como puede ser alias bla = ls. Luego hay que mantenerle el timestamp original, para esto es necesaria haberse guardado el timestamp antes de modificar el archivo, para conseguir el timestamp se utiliza el comando stat. Luego de modificarlo, se utiliza el comando touch para modificar el timestamp y poner el original, el mismo se usa con el flag -m que justamente indica que vamos a tocar el timestamp de modified. 

Luego, para cambiar el horario del sistema linux se utiliza el comando date --set= y la fecha que se quiere poner, si el cambio es hacia atras no se nota ning\'un problema porque el sistema operativo reacomoda su hora con la hora del hardware cada cierto intervalo de tiempo. Si se hace un date rapidamente despues del cambio, se vera la fecha que fue modificada, pero si se deja un lapso de tiempo, el sistema se actualiza automaticamente. Lo que se podr\'ia hacer es utilizar el comando hwclock para setear el horario del hardware.

\subsection*{Lapsos y Tiempos}
\addcontentsline{toc}{subsection}{Lapsos y tiempos}

Para conocer toda la informaci\'on que se pide en esta secci\'on hay varios comandos. En primer lugar se puede utilizar el comando uptime de la misma manera que se utiliz\'o en la primer secci\'on de este trabajo, para tener informaci\'on de cuando se prendi\'o la maquina y cuantos usuarios hay logueados. 

Sin embargo, el comando que m\'as informaci\'on pertinente nos da, es el comando last. El mismo lista todas los \'ultimos movimiento del sistema, mostrando quien se logueo, en que terminal y a que hora. As\'i como otros datos pertinentes.

\subsection*{Salida Est\'andar y Pipes}
\addcontentsline{toc}{subsection}{Salida est\'andar y pipes}

STDOUT:

En primer lugar se utiliz\'o el siguiente comando para volcar la informaci\'on pedida: ls -R $>>$ /home/grupo5/tp/config. El mismo se utiliz\'o estando en el directorio /etc, de esta manera el comando ls -R lo que hizo fue lista recusirvamente todos el contenido del directorio y su subdirectorios. Mientras que $>>$ lo que hizo fue volcar esta informaci\'on al archivo especificado.

Para obtener la informaci\'on sobre la cantidad de lineas, palabras y caracteres se utiliz\'o el comando wc con las opciones necesarios en cada caso (-l, -w, -m). El resultado fue: 665 lineas, 593 palabras y 7305 caracteres.

En tercer lugar, se buscar ordenar el contenido de /etc/passwd y ponerlo al final del archivo config anteriormente nombrado. Para ordenar se utiliz\'o el comando sort, mientras que para volcar en el archivo nuevamente se utilizo $>>$. De esta manera la sintaxis utilizada fue: sort /etc/passwd $>>$ /home/grupo5/tp/config

Por \'ultimo se procedi\'o a contar las lineas, palabras y caracteres del archivo de la misma forma que se habia realizado anteriormete, el resultado fue: 688 lineas, 621 palabras y 8238 caracteres.

\medskip


Pipes: Para realizar lo pedido, sin utilizar archivos temporales, se ejecut\'o la siguiente linea de comando que hace lo que el ejercicio pide, en el orden requerido. La sintaxis es: ls -al /usr/bin/a* | grep apt | wc. La misma es una combinaci\'on de los comandos utilizados en puntos anteriores, para lograr todos los efectos requeridos.



\section*{Scripting}
\addcontentsline{toc}{section}{Scripting}

3.3.1: En este punto se debe hacer un script que cada 5 minutos diga HOLA por pantalla. Para esto, se utilizaron dos resoluciones diferentes, una que es totalmente autom\'atica y la otra semiautom\'atica. 

Por un lado, se realizo un script de shell que, una vez ejecutado, corriese un ciclo infinito; dentro de este ciclo, el script espera 300 segundos mediante el comando sleep 300 y luego hace un echo HOLA para imprimir por pantalla la palabra requerida. Esta soluci\'on requiere que el usuario ejecute el script. Dicho script se encuentra en la carpeta /home/grupo5/tp.

Por otro lado, se encuentra otra soluci\'on totalmente autom\'atica, es decir que no requiere que el usuario ejecute el script. La misma consiste en agregar una entrada a la crontable que indique que se debe imprimir HOLA cada 5 minutos. Cabe destacar que la distribuci\'on de ubuntu utilizada para este trabajo, no cuenta con el cron por lo que fue necesario instalarlo. Una vez instalado, se agrega en la tabla la entrada correspondiente. Dicha entrada tiene la siguiente sintaxis: */5  * * * * root echo HOLA $>>$ /dev/console. Esta sintaxis dice que, cada 5 minutos, a cualquier hora, en cualquier dia, en cualquier mes y en cualquier dia de la semana; el usuario root corra el comando echo HOLA y lo imprima en la consola.

Para hacer lo mismo pero a una hora determinada, se debe explicitar la hora requerida en la entrada de la crontable. Por ejemplo, en la imagen se encuentra la entrada 25 7 * * * root echo HOLA $>>$ /dev/console. Esta entrada tiene la misma acci\'on que la anterior, pero se ejecuta todos los d\'ias a las 7 y 25. 

\bigskip


3.3.2

Hay que robarse este script!!!

\section*{Ejecuci\'on de Procesos en Background}
\addcontentsline{toc}{section}{Ejecuci\'on de procesos en background}

En primer lugar, se procedi\'o a transcribir el programa loop, se guardo el mismo en el directorio /home/grupo5/tp. Una vez transcripto, se procedio a compilar el mismo utilizando el gcc. 

\bigskip

En primer lugar el proceso se corri\'o en foreground. Esto quiere decir que el proceso toma el control de la terminal que se esta utilizando, es decir que se corre en un primer plano. El problema con este proceso es que el mismo contiene un ciclo infinito que escribe en la pantalla. Como el proceso esta corriendo en foreground, y el ciclo es infinito, el mismo nunca devuelve el control de la terminal y sigue ensuciando la consola sin poder realizar otra acci\'on. Luego, se mat\'o el proceso mediante Ctrl+C para poder interrumpirlo y as\'i volver a tomar el control de la terminal.

En segundo lugar, el proceso se corri\'o en background. Esto quier decir que el proceso queda corriendo en un segundo plano, mientras que el usuario sigue teniendo control de la terminal. Para solucionar el hecho de que el proceso ensucia la terminal, el mismo se corri\'o mandando su salida a /dev/null. Al realizar esta acci\'on, el proceso queda corriendo, pero se puede seguir haciendo uso de la terminal. 

Como este proceso no esta corriendo en foreground, Ctrl+C para matarlo no servir\'a. Es por esto que se debe matar el proceso mediante el comando kill, el mismo necesita del ID del proceso que se quiere matar. Este ID se obtiene al correr el programa, ya que al correr un proceso en background, por consola se devuelve el n\'umero de proceso asignado para, por ejemplo, saber que n\'umero tiene al querer matarlo.

\section*{IPC y Sincronizaci\'on}
\addcontentsline{toc}{section}{IPC y Sincronizaci\'on}


Facu aca me tenes que decir que hay que poner y si el codigo esta o que carajo...

\section*{El Kernel Linux}
\addcontentsline{toc}{section}{El Kernel Linux}

\subsection*{Adminsitraci\'on del procesador}
\addcontentsline{toc}{subsection}{Administraci\'on del procesador}

En cuanto a la administraci\'on del procesador de linux refiere, el sistema operativo maneja los procesos o tareas. Los procesos o tareas, son partes de un programa, o un programa entero, que cumplen alguna funci\'on espec\'ifica mediante el manipulamiento de ciertas variables y funciones. 

La administraci\'on del procesador justamente se basa en ver como manejar estos procesos para lograr que todos funcionen correctamente en tiempo y forma. 

Los procesos en un sistema operativo de tipo linux tienen varios estados:

\begin{itemize}
\item Running: Es cuando el proceso se encuentra ejecutando, tiene todos los recursos que necesita para poder funcionar correctamente.
\item Sleeping: Estos procesos se encuentran dormidos, puede ser porque son procesos interactivos que no se utilizan hace cierta cantidad de tiempo por ejemplo; o bien porque es un proceso que esta esperando alg\'un suceso para continuar.
\item Zombie: Un proceso zombie es aquel que ya no esta en funcionamiento pero que tiene una entrada en la tabla de procesos. Esto puede suceder cuando un proceso hijo termina, pero el padre todavia es capaz de ver su estado de salida por alg\'un motivo en particular. 
\item Stopped: Son procesos detenidos totalmente, pero que pueden ser reiniciados para continuar con su ejecuci\'on. 
\item Uninterruptible sleep: Son procesos que se encuentran durmiendo pero que no pueden ser interrumpidos, generalemten tienen que ver con entrada/salida del sistema operativo mismo.
\item Dead: proceso terminado que puede seguir apareciendo en el listado de procesos.
\end{itemize}


Si se esta trabajando en un sistema operativo con interfaz gr\'afica como ubuntu, se puede utilizar alguna herramiento como el gnome-system-monitor para ver todos estos procesos. A su vez, a un costado del mismo, aparecer\'a el estado del proceso, que ser\'a alguno de los anteriormente explicados.

Por otro lado, en un sistema sin interfaz gr\'afica como el utilizado para este trabajo pr\'actico se puede utilizar el comando ps con alg\'un flag que nos de toda la informaci\'on posible. Usualmente en estos casos aparece una letra que indica el estado del proceso: R de running, S de sleeping, Z de zombie, T de sTopped, U de Uninterruptible, X de dead.

\bigskip

Una vez explicados como son los procesos en linux, es importante ver como se organizan estos para su ejecuci\'on. Linux se basa en lista de prioridades para poder manejar sus procesos. Para esto, linux divide sus tareas en dos grupos:

\begin{itemize}
\item Procesos del sistema
\item Procesos de usuarios
\end{itemize}

Procesos del sistema: Para los procesos del sistema linux posee 100 listas de prioridad, donde a menor n\'umero, mayor prioridad tiene el proceso. Para este tipo de procesos linux posee dos p\'olticias diferentes para manejarlos: 
\begin{itemize}
\item FIFO: First in, First out. Es simplemente una cola, donde el primer proceso que entra, es el primer proceso que sale de la cola de prioridad. 
\item Round Robin: Es un sistema que se basa en darle un tiempo de ejecuci\'on a cada uno de los procesos. Es decir, se entrega un quantum a cada proceso, si el proceso finaliza o el quantum se agota, el proceso es desalojado.
\end{itemize}

Procesos de usuarios:
Para estos procesos linux posee 40 listas de prioridad, numeradas desde -20 hasta 19. Para estos procesos el sistema operativo se encarga de alternarlos de manera que no haya ninguno que se encuentre mucho tiempo inactivo. Para esto el sistema se encarga de penalizar los procesos que tienen mucho tiempo de cpu, y trata de darle m\'as prioridad a los procesos que tienen m\'as entrada/salida, que se supone que estuvieron bloqueados una mayor cantidad de tiempo.

Por defecto, el proceso cuando se ejecuta tiene nivel de prioridad cero. Si se quiere que un proceso tenga una prioridad diferente, se puede utilizar el comando nice para realizar un cambio de prioridad. Si la prioridad a asignar es positiva, es decir una prioridad menor, se puede hacer directamente. Si, por el contrario, se quiere asignar una prioridad mayor, es decir negativa, se necesitan permisos de superusuario.

En el caso que un proceso ya se encuentre en ejecuci\'on, se puede cambiar la prioridad del mismo sin necesidad de matarlo. Esto se puede hacer con el comando renice, que reasigna prioridad en tiempo de ejecuci\'on.

\subsection*{Administraci\'on de la memoria}
\addcontentsline{toc}{subsection}{Administraci\'on de la memoria}

La administraci\'on de la memoria en linux, al igual que en la mayor\'ia de los sistemas operativos modernos, es pagina por demanda debido a que resulta efectivo poder simular mayor cantidad de memoria ram utilizando otro dispositivo como el disco duro. Linux posee paginas de 4kb o 4mb dependiendo la arquitectura del procesador y contiene un espacio especial de memoria en el disco denominado memoria swap donde justamente hace el intercambio entre las paginas que se encuentran en memoria principal y las que se encuentran en memoria secundaria seg\'un las necesidades requeridas. Esta memoria swap se puede asignar manualmente al instalar el sistema operativo y tiene como consecuencia una mejor o peor eficiencia del manejo de la memoria virtual. 

Cabe destacar, que al momento de realizar los intercambios, el sistema operativo linux toma una pol\'itica LRU, last recently used, es decir que la pagina elegida para ser removida de memoria principal es la que m\'as tiempo lleva sin ser referenciada.

\subsection*{Sistema de archivos}
\addcontentsline{toc}{subsection}{Sistema de archivos}

El sistema de archivos de linux es, basicamente, el heredado del sistema UNIX. El mismo es un sistema de archivo jerarquico, donde todo se toma o como un directorio o como un archivo. Este sistema de archivo es jerarquicos, ya que los directorios con sus subdirectorios correspondientes tiene una topolog\'ia de arbol donde se encuentra el directorio root y luego todos los dem\'as, colgando de este primero. 

Es importante destacar que para el filesystem de linux, todo es un archivo o un directorio, es por esto que se puede acceder por ejemplo a los dispositivos de la misma manera que a cualquier otro directorio. Por ejemplo, si se escribe informaci\'on en el directorio /dev/dsp, se podra escuchar esta informaci\'on por los parlantes dado que este directorio corresponde al dispositivo de sonido.

Al heredar este filesystem de UNIX, el mismo posee las mismas propiedas a bajo nivel, es decir que los medios de representaci\'on son los i-nodos. Adem\'as, el sistema posee un Virtual file system que se encarga de ver los filesystem que se pueden ir montando sobre el original. 


\subsection*{M\'odulos del sistema operativo}
\addcontentsline{toc}{subsection}{M\'odulos del sistema operativo}

En primer lugar se encuentra el m\'odulo de hello.c otorgado por la c\'atera, este m\'odulo se encuentra en la imagen del sistema operativo y fue probado con exito sin ninguna otra observaci\'on particular.

\bigskip

Por otro lado, se encuentra el m\'odulo para manejar las luces del teclado:
\begin{itemize}
\item En primer lugar se compilo el programa entregado por la c\'atedra para poder ver el estado de las luces.
\item Se procedio a realizar el m\'odulo correspondiente, el mismo se encarga de crear un archivo en el directorio /proc que sirve para manejar los leds. Cuando se escribe en el mismo, cambia el estado de los leds, seg\'un lo que se haya escrito en el archivo creado. Una vez instalado el modulo, se puede ver como haciendo echo Q $>>$ /proc/archivo, se prende la luz correspondiente, y dicha acci\'on se puede monitorear con el programa anteriormente mencionado. 

Cabe destacar que este m\'odulo se inserto con \'exito en el sistema operativo de la maquina host, donde si se poseen leds; y se pudo ver como escribiendo en el archivo correspondiente se pueden controlar los leds sin necesidad de presionar el boton correspondiente.
\end{itemize}



\section*{Temas del Sistema Operativo}
\addcontentsline{toc}{section}{Temas del Sistema Operativo}

\subsection*{Comunicaci\'on}
\addcontentsline{toc}{subsection}{Comunicaci\'on}

Para poder compartir una carpeta entre el host y el guest se deben seguir los siguientes pasos:

\begin{itemize}
\item En primer lugar hay que dirigirse dentro de la maquina virtual a Devices y luego hacer click en la opci\'on Guest Additions. Montando en el cd esta opci\'on.
\item Luego se ejecuta el archivo de instalaci\'on dependiendo de la versi\'on utilizada. En nuestro caso corresponde a linux86
\item Luego tenemos que agregar la carpeta del host que queremos compartir. Esta carpeta fue previamente creada en el host y luego se debe agregar la carpeta yendo a devices y ahi dentro a la opci\'on shared folders. 
\item Luego debemos crear la carpete dentro del sistema operativo en la maquina virtual.
\item Por \'ultimo hay que sincronizar estas dos carpetas. Esto se hace mediante el comando sudo mount -t vboxsf nombreCarpetaHost nombreCarpetaGuest
\item Ya se pueden compartir archivos poniendolos directamente en dicha carpeta, tanto de host a guest como al reves. 
\end{itemize}


\subsection*{File System}
\addcontentsline{toc}{subsection}{File System}

Como se explico en puntos anteriores, linux hereda el file system de UNIX. Es por esto que un hardlink apunta a la misma estructura que se encontraba presente en el file system de UNIX, es decir a los i-nodos. El i-nodo es un bloque que guarda informaci\'on sobre el archivo o directorio al cual hace referencia; guarda toda la informaci\'on necesaria no solo para poder referenciar el espacio f\'isico del mismo, sino para tener la informaci\'on pertinente. 

El i-nodo guarda mucha informaci\'on como el id del usuario owner, el id del grupo, que tan grande es el archivo y los punteros a los bloques f\'isicos donde se encuentra el archivo. Pero, adem\'as, posee un campo importante que es el contador de hardlinks, esto indica cuantos hardlinks estan haciendo referencia a este mismo i-nodo. 


Un hardlink es una referencia directa al i-nodo y al archivo o directorio en cuestion. Si se tienen dos hardlinks al mismo archivo en diferentes directorios, es como tener dos copias del mismo archivo, pero que en realidad hacen referencia a una sola y por lo tanto no hay desperdicio de bytes. Cabe destacar que si una copia es alterada, entonces todas las copias apuntadas por otros hardlinks son alteradas, ya que el archivo en cuesti\'on es solamente uno. 

A diferencia de estos, los softlinks nada mas son un acceso directo al archivo, si el archivo original se borra el softlinks queda huerfano.

La idea de que un i-nodo tenga contandores de hardlinks es para saber cuantas falsas copias del archivo hay dando vueltas. Entonces, se puede borrar un hardlink sin que el archivo sufra ning\'un tipo de cambio, ya que lo \'unico que sucede es que el contador de hardlinks baja en uno, y los dem\'as siguen apuntando al archivo como lo hac\'ian antes. En el caso de que se borren todos los hardlinks, ya no quedan referencias al archivo, por lo que se puede borrar el mismo. 


\subsection*{Prioridades}
\addcontentsline{toc}{subsection}{Prioridades}

Para ejecutar los procesos en background se hace lo mismo que se explico en secciones anteriores. Es decir, se utiliza el ampersand para que se ejecute en un segundo plano y se manda el flujo de salida a /dev/null para que no se ensucie la consola. Luego, lo importante del ejercicio es ver como el loop3 se corre con mayor prioridad, para esto se utiliza lo explicado en administraci\'on del procesador, utilizar el comando nice para cambiarle la prioridad y poder as\'i ver como toma m\'as porcentaje del cpu.

La sintaxis utilizada entonces es:
$loop1 >> /dev/null$ \&

$./loop2 >> /dev/null$ \&

nice -n -18 $./loop3 >> /dev/null$ \&


Luego, utilizando el comando top se puede ver cual es el tiempo de cpu que requiere cada proceso. Cabe destacar que al utilizar el comando top solo se observa el id del proceso, los ids de dichos procesos se obtienen al ejecutarlos en background. Luego de ejecutarlos en background, se imprime por consola el id del mismo.

\subsection*{Par\'ametros del Kernel}
\addcontentsline{toc}{subsection}{Par\'ametros del Kernel}

En primer lugar, vamos a utilizar un comando que ya se utiliz\'o anteriormente en este trabajo. Dicho comando es el free, el mismo nos indica cuanta memoria se posee y cuanta se esta utilizando.

Luego, tenemos que lograr que el sistema use menos memoria, si bien se podr\'ia limitar que procesos se utilizan, la idea final de este punto es poder imponer una restricci\'on mayor a una solucion ad hoc que ser\'ia ir deshaciendo de procesos a medida que la memoria ram sube. La idea entonces es restringir de entrada al sistema para que no puede usar m\'as memoria ram que una cierta cantidad predispuesta.

Para esto, lo que se hizo, fue agregar una entrada a la lista del grub, para poder bootear la maquina en un modo donde la memoria ram se encuentre limitada por un par\'ametro puesto por el grupo.

Como crear una entrada al grub puede ser complicado debido a que desconocemos los par\'ametros que se utilizan, lo que se hizo fue copiar la entrada default, es decir, la entrada que se estuvo ejecutando todas las veces que iniciamos la maquina. 

Luego, lo que se le hizo a esta entrada fue agregarle el par\'ametro mem=200M. De esta manera, la entrada, y por ende todos los atributos del sistema, son iguales a lo que teniamos anteriormente, pero con la diferencia de que tiene la memoria ram restringida. De esta manera, al reiniciar el sistema, se puede ver como el grub ahora nos da la opci\'on que teniamos anteriormente, y una segunda opci\'on que es el mismo sistema pero con la memoria ram restringida. 

Una vez iniciada la maquina en esta nueva modalidad, se puede volver a utilizar el comando free para ver como cambio el uso de memoria ram.

\subsection*{Administraci\'on de la Memoria}
\addcontentsline{toc}{subsection}{Administraci\'on de la Memoria}





\end{document}


bibliografia:

http://www.linux-es.org/node/127 pagina para explicacion de chgrp, chown y chmod
http://www.oreillynet.com/linux/cmd pagina de comandos de linux
http://www.computerhope.com/unix pagina de comandos de linux
http://linuxcommand.gds.tuwien.ac.at paginas para hacer scripts
http://www.bulma.net/body.phtml?nIdNoticia=50 Habla sobre .profile y .bashrc
http://bloggerdigest.blogspot.com/2006/10/enable-linux-login-logout-scripts.html explicar como hacer el script para el logout.
http://www.linuxforums.org/forum/linux-programming-scripting/12551-simple-shutdown-script.html Script para apagar automaticamente

http://www.debian-administration.org/article/Making_scripts_run_at_boot_time_with_Debian Script para poner Buenos Dias cuando se prende

http://www.laps3.com/foro/19_guias_tutoriales/23114-manual_de_shell_linux_comandos_basicos_utilizaion_ejemplos.html Pagina que ensena a contar palabras, lineas y caracteres.

http://www.unix.com/es/shell-programming-scripting/111483-script-run-every-5-minutes.html

http://www.hedeshian.com/node/12 Pagina que explicar que el ubuntu jeos no viene con crontab

http://www.linuxtotal.com.mx/index.php?cont=info_admon_006 manual de cron

http://www.ace.ual.es/~vruiz/docencia/cursos/linux/html/node48.html pagina que explicar que significa correr en background y foreground

Pagina para hacer modulos de leds
http://tldp.org/LDP/lkmpg/2.6/html/x1194.html
